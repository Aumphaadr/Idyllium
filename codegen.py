# codegen.py
from iast import *
from typing import List

class CodeGenerator:
    def __init__(self):
        self.lines = []
        self.indent_level = 0
        self.used_modules = set()

    def _indent(self) -> str:
        return "    " * self.indent_level

    def _emit(self, code: str):
        self.lines.append(self._indent() + code)

    def generate(self, program: Program) -> str:
        # 1. Заголовок и обёртки
        self._emit("# Auto-generated by Idyllium compiler")
        self._emit("import sys")
        self._emit("")

        # 2. Объявим обёртки (минимальный runtime)
        self._emit("def __idyl_write(*args):")
        self.indent_level += 1
        self._emit("for arg in args:")
        self.indent_level += 1
        self._emit("sys.stdout.write(str(arg))")
        self.indent_level -= 1
        self._emit("sys.stdout.flush()")
        self.indent_level -= 1
        self._emit("")

        self._emit("def __idyl_get_string():")
        self.indent_level += 1
        self._emit("return sys.stdin.readline().rstrip('\\n')")
        self.indent_level -= 1
        self._emit("")

        self._emit("def __idyl_get_int():")
        self.indent_level += 1
        self._emit("try:")
        self.indent_level += 1
        self._emit("return int(sys.stdin.readline().rstrip('\\n'))")
        self.indent_level -= 1
        self._emit("except ValueError:")
        self.indent_level += 1
        self._emit("print(\"Ошибка: ожидалось целое число\", file=sys.stderr)")
        self._emit("sys.exit(1)")
        self.indent_level -= 1
        self.indent_level -= 1
        self._emit("")

        self._emit("def __idyl_get_float():")
        self.indent_level += 1
        self._emit("try:")
        self.indent_level += 1
        self._emit("return float(sys.stdin.readline().rstrip('\\n'))")
        self.indent_level -= 1
        self._emit("except ValueError:")
        self.indent_level += 1
        self._emit("print(\"Ошибка: ожидалось дробное число\", file=sys.stderr)")
        self._emit("sys.exit(1)")
        self.indent_level -= 1
        self.indent_level -= 1
        self._emit("")

        # 3. Обработаем импорты
        for imp in program.imports:
            if imp.module_name == "console":
                self.used_modules.add("console")
            elif imp.module_name == "random":
                self._emit("import random")
                self.used_modules.add("random")
            # Другие модули — по мере добавления
        if program.imports:
            self._emit("")

        # 4. Генерация main()
        self._generate_function(program.main_func)

        # 5. Точка входа
        self._emit("")
        self._emit("if __name__ == \"__main__\":")
        self.indent_level += 1
        self._emit("main()")
        self.indent_level -= 1

        return "\n".join(self.lines)

    def _generate_function(self, func: FunctionDecl):
        self._emit(f"def {func.name}():")
        self.indent_level += 1
        for stmt in func.body.statements:
            self._generate_stmt(stmt)
        self.indent_level -= 1
        self._emit("")

    def _generate_stmt(self, stmt: Stmt):
        if isinstance(stmt, VarDecl):
            value = self._generate_expr(stmt.initializer)
            self._emit(f"{stmt.name} = {value}")
        elif isinstance(stmt, ExprStmt):
            expr_code = self._generate_expr(stmt.expr)
            self._emit(expr_code)
        elif isinstance(stmt, Block):
            for s in stmt.statements:
                self._generate_stmt(s)
        elif isinstance(stmt, IfStmt):
            self._generate_if(stmt)
        elif isinstance(stmt, WhileStmt):
            self._generate_while(stmt)
        elif isinstance(stmt, ReturnStmt):
            if stmt.value:
                val = self._generate_expr(stmt.value)
                self._emit(f"return {val}")
            else:
                self._emit("return")
        else:
            raise NotImplementedError(f"Неизвестный тип оператора: {type(stmt)}")

    def _generate_expr(self, expr: Expr) -> str:
        if isinstance(expr, Literal):
            if isinstance(expr.value, str):
                # Строка или символ — оба str в Python
                if len(expr.value) == 1 and expr.value in '\n\t\r\\\'"':
                    # Это символ — но в Python нет отдельного типа, так что просто строка
                    return repr(expr.value)
                else:
                    return repr(expr.value)
            elif isinstance(expr.value, bool):
                return "True" if expr.value else "False"
            else:
                return str(expr.value)
        elif isinstance(expr, Variable):
            return expr.name
        elif isinstance(expr, Assign):
            value = self._generate_expr(expr.value)
            return f"{expr.name} = {value}"
        elif isinstance(expr, Binary):
            left = self._generate_expr(expr.left)
            right = self._generate_expr(expr.right)
            op_map = {
                "+": "+", "-": "-", "*": "*", "/": "/",
                "==": "==", "!=": "!=",
                "<": "<", "<=": "<=", ">": ">", ">=": ">=",
                "and": "and", "or": "or"
            }
            op = op_map.get(expr.operator)
            if op is None:
                raise NotImplementedError(f"Оператор не поддерживается: {expr.operator}")
            return f"({left} {op} {right})"
        elif isinstance(expr, Unary):
            right = self._generate_expr(expr.right)
            if expr.operator == "-":
                return f"(-{right})"
            elif expr.operator == "not":
                return f"(not {right})"
            else:
                raise NotImplementedError(f"Неизвестный унарный оператор: {expr.operator}")
        elif isinstance(expr, Call):
            callee = self._generate_expr(expr.callee)
            args = ", ".join(self._generate_expr(arg) for arg in expr.arguments)
            # Особая обработка console.write → __idyl_write
            # В _generate_expr, внутри elif isinstance(expr, Call):
            if callee == "console.write":
                return f"__idyl_write({args})"
            elif callee == "console.get_int":
                if len(expr.arguments) != 0:
                    raise RuntimeError("console.get_int() не принимает аргументов")
                return "__idyl_get_int()"
            elif callee == "console.get_float":
                if len(expr.arguments) != 0:
                    raise RuntimeError("console.get_float() не принимает аргументов")
                return "__idyl_get_float()"
            elif callee == "console.get_string":
                if len(expr.arguments) != 0:
                    raise RuntimeError("console.get_string() не принимает аргументов")
                return "__idyl_get_string()"
            elif callee == "to_string":
                arg = self._generate_expr(expr.arguments[0])
                return f"str({arg})"
            elif callee == "to_int":
                arg = self._generate_expr(expr.arguments[0])
                return f"int({arg})"
            elif callee == "to_float":
                arg = self._generate_expr(expr.arguments[0])
                return f"float({arg})"
            elif isinstance(expr.callee, Get) and expr.callee.name == "length":
                obj = self._generate_expr(expr.callee.object)
                return f"len({obj})"
            else:
                return f"{callee}({args})"
        elif isinstance(expr, Get):
            obj = self._generate_expr(expr.object)
            return f"{obj}.{expr.name}"
        else:
            raise NotImplementedError(f"Неизвестный тип выражения: {type(expr)}")

    def _generate_if(self, stmt: IfStmt):
        condition = self._generate_expr(stmt.condition)
        self._emit(f"if {condition}:")
        self.indent_level += 1
        self._generate_stmt(stmt.then_branch)
        self.indent_level -= 1
        if stmt.else_branch:
            self._emit("else:")
            self.indent_level += 1
            self._generate_stmt(stmt.else_branch)
            self.indent_level -= 1

    def _generate_while(self, stmt: WhileStmt):
        condition = self._generate_expr(stmt.condition)
        self._emit(f"while {condition}:")
        self.indent_level += 1
        self._generate_stmt(stmt.body)
        self.indent_level -= 1