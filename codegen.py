# codegen.py
from iast import *
from typing import List

BUILTIN_MODULES = {"console", "random", "time", "file"}

class CodeGenerator:
    def __init__(self):
        self.lines = []
        self.indent_level = 0
        self.used_modules = set()
        self.user_libraries = {}

    def _indent(self) -> str:
        return "    " * self.indent_level

    def _emit(self, code: str):
        self.lines.append(self._indent() + code)

    def generate(self, program: Program) -> str:
        self._emit("# Auto-generated by Idyllium compiler")
        self._emit("import sys")
        self._emit("")

        self._emit("def __idyl_write(*args):")
        self.indent_level += 1
        self._emit("for arg in args:")
        self.indent_level += 1
        self._emit("sys.stdout.write(str(arg))")
        self.indent_level -= 1
        self._emit("sys.stdout.flush()")
        self.indent_level -= 1
        self._emit("")

        self._emit("def __idyl_get_string():")
        self.indent_level += 1
        self._emit("return sys.stdin.readline().rstrip('\\n')")
        self.indent_level -= 1
        self._emit("")

        self._emit("def __idyl_get_int():")
        self.indent_level += 1
        self._emit("try:")
        self.indent_level += 1
        self._emit("return int(sys.stdin.readline().rstrip('\\n'))")
        self.indent_level -= 1
        self._emit("except ValueError:")
        self.indent_level += 1
        self._emit("print(\"Ошибка: ожидалось целое число\", file=sys.stderr)")
        self._emit("sys.exit(1)")
        self.indent_level -= 1
        self.indent_level -= 1
        self._emit("")

        self._emit("def __idyl_get_float():")
        self.indent_level += 1
        self._emit("try:")
        self.indent_level += 1
        self._emit("return float(sys.stdin.readline().rstrip('\\n'))")
        self.indent_level -= 1
        self._emit("except ValueError:")
        self.indent_level += 1
        self._emit("print(\"Ошибка: ожидалось дробное число\", file=sys.stderr)")
        self._emit("sys.exit(1)")
        self.indent_level -= 1
        self.indent_level -= 1
        self._emit("")

        for imp in program.imports:
            if imp.module_name == "random":
                self._emit("import random")
                self.used_modules.add("random")
        self._emit("")

        for func in program.global_functions:
            self._generate_function(func)
        if program.global_functions:
            self._emit("")

        for lib_name, funcs in self.user_libraries.items():
            for func in funcs:
                params_str = ""
                if func.params:
                    params_str = ", ".join(p.name for p in func.params)
                self._emit(f"def {lib_name}_{func.name}({params_str}):")
                self.indent_level += 1
                for stmt in func.body.statements:
                    self._generate_stmt(stmt)
                self.indent_level -= 1
                self._emit("")
        if self.user_libraries:
            self._emit("")

        self._generate_function(program.main_func)

        self._emit("")
        self._emit("if __name__ == \"__main__\":")
        self.indent_level += 1
        self._emit("main()")
        self.indent_level -= 1

        return "\n".join(self.lines)

    def _generate_function(self, func: FunctionDecl):
        params_str = ""
        if func.params:
            params_str = func.params[0].name
        self._emit(f"def {func.name}({params_str}):")
        self.indent_level += 1
        for stmt in func.body.statements:
            self._generate_stmt(stmt)
        self.indent_level -= 1
        self._emit("")

    def _generate_stmt(self, stmt: Stmt):
        if isinstance(stmt, VarDecl):
            value = self._generate_expr(stmt.initializer)
            self._emit(f"{stmt.name} = {value}")
        elif isinstance(stmt, ExprStmt):
            expr_code = self._generate_expr(stmt.expr)
            self._emit(expr_code)
        elif isinstance(stmt, Block):
            for s in stmt.statements:
                self._generate_stmt(s)
        elif isinstance(stmt, IfStmt):
            self._generate_if(stmt)
        elif isinstance(stmt, WhileStmt):
            self._generate_while(stmt)
        elif isinstance(stmt, ReturnStmt):
            if stmt.value:
                val = self._generate_expr(stmt.value)
                self._emit(f"return {val}")
            else:
                self._emit("return")
        else:
            raise NotImplementedError(f"Неизвестный тип оператора: {type(stmt)}")

    def _generate_expr(self, expr: Expr) -> str:
        if isinstance(expr, Literal):
            if isinstance(expr.value, str):
                if len(expr.value) == 1 and expr.value in '\n\t\r\\\'"':
                    return repr(expr.value)
                else:
                    return repr(expr.value)
            elif isinstance(expr.value, bool):
                return "True" if expr.value else "False"
            else:
                return str(expr.value)
        elif isinstance(expr, Variable):
            return expr.name
        elif isinstance(expr, Assign):
            value = self._generate_expr(expr.value)
            return f"{expr.name} = {value}"
        elif isinstance(expr, Binary):
            left = self._generate_expr(expr.left)
            right = self._generate_expr(expr.right)
            op_map = {
                "+": "+", "-": "-", "*": "*", "/": "/",
                "==": "==", "!=": "!=",
                "<": "<", "<=": "<=", ">": ">", ">=": ">=",
                "and": "and", "or": "or"
            }
            op = op_map.get(expr.operator)
            if op is None:
                raise NotImplementedError(f"Оператор не поддерживается: {expr.operator}")
            return f"({left} {op} {right})"
        elif isinstance(expr, Unary):
            right = self._generate_expr(expr.right)
            if expr.operator == "-":
                return f"(-{right})"
            elif expr.operator == "not":
                return f"(not {right})"
            else:
                raise NotImplementedError(f"Неизвестный унарный оператор: {expr.operator}")
        elif isinstance(expr, Call):
            callee = self._generate_expr(expr.callee)
            args = ", ".join(self._generate_expr(arg) for arg in expr.arguments)
            if callee == "console.write":
                return f"__idyl_write({args})"
            elif callee == "console.get_int":
                if len(expr.arguments) != 0:
                    raise RuntimeError("console.get_int() не принимает аргументов")
                return "__idyl_get_int()"
            elif callee == "console.get_float":
                if len(expr.arguments) != 0:
                    raise RuntimeError("console.get_float() не принимает аргументов")
                return "__idyl_get_float()"
            elif callee == "console.get_string":
                if len(expr.arguments) != 0:
                    raise RuntimeError("console.get_string() не принимает аргументов")
                return "__idyl_get_string()"
            elif callee == "to_string":
                arg = self._generate_expr(expr.arguments[0])
                return f"str({arg})"
            elif callee == "to_int":
                arg = self._generate_expr(expr.arguments[0])
                return f"int({arg})"
            elif callee == "to_float":
                arg = self._generate_expr(expr.arguments[0])
                return f"float({arg})"
            elif isinstance(expr.callee, Get) and expr.callee.name == "length":
                obj = self._generate_expr(expr.callee.object)
                return f"len({obj})"
            elif isinstance(expr.callee, Get):
                obj = expr.callee.object
                method = expr.callee.name
                if isinstance(obj, Variable):
                    lib_name = obj.name
                    if lib_name in self.user_libraries:
                        prefixed_name = f"{lib_name}_{method}"
                        return f"{prefixed_name}({args})"
            return f"{callee}({args})"
        elif isinstance(expr, Get):
            obj = self._generate_expr(expr.object)
            return f"{obj}.{expr.name}"
        else:
            raise NotImplementedError(f"Неизвестный тип выражения: {type(expr)}")

    def _generate_if(self, stmt: IfStmt):
        condition = self._generate_expr(stmt.condition)
        self._emit(f"if {condition}:")
        self.indent_level += 1
        self._generate_stmt(stmt.then_branch)
        self.indent_level -= 1
        if stmt.else_branch:
            self._emit("else:")
            self.indent_level += 1
            self._generate_stmt(stmt.else_branch)
            self.indent_level -= 1

    def _generate_while(self, stmt: WhileStmt):
        condition = self._generate_expr(stmt.condition)
        self._emit(f"while {condition}:")
        self.indent_level += 1
        self._generate_stmt(stmt.body)
        self.indent_level -= 1